@tool
extends Node

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

## Interaction with the Twitch REST API.
class_name TwitchRestAPI

## Maximal tries to reauthrorize before giving up the request.
const MAX_AUTH_ERRORS = 3

## Called when the API returns unauthenticated mostly cause the accesstoken is expired
signal unauthenticated

## Called when the API returns 403 means there are permissions / scopes missing
signal unauthorized

## Broadcaster ID that will be used when no Broadcaster ID was given
@export var default_broadcaster_id: String
## To authorize against the Twitch API
@export var token: OAuthToken
## OAuth settings needed for client information
@export var oauth_setting: OAuthSetting
## Client Manger to provide HTTP requests
@export var http_client_manager: HttpClientManager
## URI to the Twitch API
@export var api_host: String = "https://api.twitch.tv"

var log: TwitchLogger = TwitchLogger.new("TwitchAPI")
var client: BufferedHTTPClient


func _ready() -> void:
	client = http_client_manager.get_client(api_host)


func request(path: String, method: int, body: Variant = "", content_type: String = "", error_count: int = 0) -> BufferedHTTPClient.ResponseData:
	var header : Dictionary = {
		"Authorization": "Bearer %s" % [await token.get_access_token()],
		"Client-ID": oauth_setting.client_id
	}
	if content_type != "":
		header["Content-Type"] = content_type

	var request_body: String = ""
	if body == null || (body is String && body == ""):
		request_body = ""
	elif body is Object && body.has_method("to_json"):
		request_body = body.to_json()
	else:
		request_body = JSON.stringify(body)

	var request = client.request(path, method, header, request_body)
	var response = await client.wait_for_request(request)

	# Token expired / or missing permissions
	if response.client.get_response_code() == 403:
		log.e("'%s' is unauthorized. It is probably your scopes.")
		unauthorized.emit()
	if response.client.get_response_code() == 401:
		unauthenticated.emit()
		await token.authorized
		if error_count + 1 < MAX_AUTH_ERRORS:
			return await request(path, method, body, content_type, error_count + 1)
		else:
			# Give up the request after trying multiple times and
			# return an empty response with correct error code
			var empty_response = client.empty_response(request)
			empty_response.response_code = response.client.get_response_code()
			return empty_response
	return response

{for methods as method}
{method}

{/for}

## Converts unix timestamp to RFC 3339 (example: 2021-10-27T00:00:00Z) when passed a string uses as is
static func get_rfc_3339_date_format(time: Variant) -> String:
	if typeof(time) == TYPE_INT:
		var date_time = Time.get_datetime_dict_from_unix_time(time)
		return "%s-%02d-%02dT%02d:%02d:%02dZ" % [date_time['year'], date_time['month'], date_time['day'], date_time['hour'], date_time['minute'], date_time['second']]
	return str(time)
