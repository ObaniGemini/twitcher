@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchSendChatMessage
	


## 
## #/components/schemas/SendChatMessageBody
class Body extends TwitchData:

	## The ID of the broadcaster whose chat room the message will be sent to.
	@export var broadcaster_id: String:
		set(val): 
			broadcaster_id = val
			track_data(&"broadcaster_id", val)
	
	## The ID of the user sending the message. This ID must match the user ID in the user access token.
	@export var sender_id: String:
		set(val): 
			sender_id = val
			track_data(&"sender_id", val)
	
	## The message to send. The message is limited to a maximum of 500 characters. Chat messages can also include emoticons. To include emoticons, use the name of the emote. The names are case sensitive. Donâ€™t include colons around the name (e.g., :bleedPurple:). If Twitch recognizes the name, Twitch converts the name to the emote before writing the chat message to the chat room
	@export var message: String:
		set(val): 
			message = val
			track_data(&"message", val)
	
	## The ID of the chat message being replied to.
	@export var reply_parent_message_id: String:
		set(val): 
			reply_parent_message_id = val
			track_data(&"reply_parent_message_id", val)
	
	## **NOTE:** This parameter can only be set when utilizing an App Access Token. It cannot be specified when a User Access Token is used, and will instead result in an HTTP 400 error.  
	##   
	## Determines if the chat message is sent only to the source channel (defined by _broadcaster\_id_) during a shared chat session. This has no effect if the message is sent during a shared chat session.  
	##   
	## If this parameter is not set, the default value when using an App Access Token is `false`. On May 19, 2025 the default value for this parameter will be updated to `true`, and chat messages sent using an App Access Token will only be shared with the source channel by default. If you prefer to send a chat message to both channels in a shared chat session, make sure this parameter is explicitly set to `false` in your API request before May 19.
	@export var for_source_only: bool:
		set(val): 
			for_source_only = val
			track_data(&"for_source_only", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_broadcaster_id: String, _sender_id: String, _message: String) -> Body:
		var body: Body = Body.new()
		body.broadcaster_id = _broadcaster_id
		body.sender_id = _sender_id
		body.message = _message
		return body
	
	
	static func from_json(d: Dictionary) -> Body:
		var result: Body = Body.new()
		if d.get("broadcaster_id", null) != null:
			result.broadcaster_id = d["broadcaster_id"]
		if d.get("sender_id", null) != null:
			result.sender_id = d["sender_id"]
		if d.get("message", null) != null:
			result.message = d["message"]
		if d.get("reply_parent_message_id", null) != null:
			result.reply_parent_message_id = d["reply_parent_message_id"]
		if d.get("for_source_only", null) != null:
			result.for_source_only = d["for_source_only"]
		return result
	


## 
## #/components/schemas/SendChatMessageResponse
class Response extends TwitchData:

	## 
	@export var data: Array[ResponseData]:
		set(val): 
			data = val
			track_data(&"data", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_data: Array[ResponseData]) -> Response:
		var response: Response = Response.new()
		response.data = _data
		return response
	
	
	static func from_json(d: Dictionary) -> Response:
		var result: Response = Response.new()
		if d.get("data", null) != null:
			for value in d["data"]:
				result.data.append(ResponseData.from_json(value))
		return result
	


## 
## #/components/schemas/SendChatMessageResponse/Data
class ResponseData extends TwitchData:

	## The message id for the message that was sent.
	@export var message_id: String:
		set(val): 
			message_id = val
			track_data(&"message_id", val)
	
	## If the message passed all checks and was sent.
	@export var is_sent: bool:
		set(val): 
			is_sent = val
			track_data(&"is_sent", val)
	
	## The reason the message was dropped, if any.
	@export var drop_reason: ResponseDropReason:
		set(val): 
			drop_reason = val
			track_data(&"drop_reason", val)
	
	
	
	## Constructor with all required fields.
	static func create(_message_id: String, _is_sent: bool) -> ResponseData:
		var response_data: ResponseData = ResponseData.new()
		response_data.message_id = _message_id
		response_data.is_sent = _is_sent
		return response_data
	
	
	static func from_json(d: Dictionary) -> ResponseData:
		var result: ResponseData = ResponseData.new()
		if d.get("message_id", null) != null:
			result.message_id = d["message_id"]
		if d.get("is_sent", null) != null:
			result.is_sent = d["is_sent"]
		if d.get("drop_reason", null) != null:
			result.drop_reason = ResponseDropReason.from_json(d["drop_reason"])
		return result
	


## The reason the message was dropped, if any.
## #/components/schemas/SendChatMessageResponse/Data/DropReason
class ResponseDropReason extends TwitchData:

	## Code for why the message was dropped.
	@export var code: String:
		set(val): 
			code = val
			track_data(&"code", val)
	
	## Message for why the message was dropped.
	@export var message: String:
		set(val): 
			message = val
			track_data(&"message", val)
	
	
	
	## Constructor with all required fields.
	static func create(_code: String, _message: String) -> ResponseDropReason:
		var response_drop_reason: ResponseDropReason = ResponseDropReason.new()
		response_drop_reason.code = _code
		response_drop_reason.message = _message
		return response_drop_reason
	
	
	static func from_json(d: Dictionary) -> ResponseDropReason:
		var result: ResponseDropReason = ResponseDropReason.new()
		if d.get("code", null) != null:
			result.code = d["code"]
		if d.get("message", null) != null:
			result.message = d["message"]
		return result
	